\setcounter{secnumdepth}{3} %para tener una profundidad más en las enumeraciones
\chapter{Implementaci\'on}
\label{cap:implementacion}
En el Capítulo 3 se abordó la descripción de la herramienta sin entrar en detalles de como funcionaba esta por debajo, una visión general de lo que se iba a ofrecer, como la organización de los componentes, los tipos de daño o los diferentes tipos de actuadores. En este capítulo se va a tratar en profundidad la implementación de estos componentes, hablando de cómo funcionan, cómo se pueden personalizar y como los distintos componentes interactúan entre ellos.


\section{Tecnología utilizada}
Este proyecto ha sido desarrollado íntegramente con el motor de videojuegos Unity, mencionado en el Capítulo 2 de este trabajo.
La versión escogida para desarrollar la herramientas es la 2022.3.18f1, por lo que no podemos garantizar que la herramienta funcione en versiones anteriores a la mencionada y en el caso de la versiones posteriores debería funcionar sin ningún problema a no ser que la API básica de Unity cambie en un futuro.\\
\comp{En trabajo futuro podemos poner que en caso de que se cambie la API básica necesitaría algo de mantenimiento básico.}

Unity es una herramienta muy versátil, la cúal se adapta muy bien a un gran rango de aplicaciones diferentes entre sí, desde entornos simples en dos dimensiones hasta entornos mucho más complejos en tres dimensiones, incluso en realidad virtual o realidad aumentada.
Unity surge de la idea de acercar el desarrollo de videojuegos a segmentos de la población que se podrían ver abrumados por la necesidad de entender de programación para realizar sus proyectos ya sean estos profesionales o amateurs.Este motor de videojuegos ofrece soporte para varios lenguajes de programación a través de su sistema de \textit{plugins}, de manera nativa Unity nos ofrece los lenguajes C\# y Javascript como principales lenguajes de programación de \textit{scripts}.\\

Unity cuenta con una interfaz de usuario muy gráfica la cúal resulta muy intuitiva dentro de su complejidad. También es importante mencionar la personalización de su interfaz otorgando al usuario la capacidad de distribuir en pantalla las distintas ventanas que componen la interfaz de usuario de la manera más cómoda posible.
Otro elemento muy importante de Unity es el sistema \textit{drag and drop} el cual nos permite construir las escenas de juego de manera muy sencilla, moviendo los objetos en la escena haciendo click y arrastrándolos y también permite asignar scripts a las entidades de juego de la misma manera. Con respecto a la curva de aprendizaje de Unity esta no es muy pronunciada ya que desde Unity como empresa se toman muy enserio el tener una documentación clara y accesible, así como habilitar foros y tutoriales para que sea la propia comunidad de usuarios la que se ayuda así misma.\\


El motivo por el que se escoge Unity sobre los demás motores de videojuegos es esa accesibilidad que ha sido mencionada anteriormente que hace que Unity resulte sencillo de utilizar por cualquier persona. Otro motivo de peso por el que hemos considerado Unity como nuestra opción principal de motor de videojuegos es la cantidad de usuarios que lo usan día a día lo que lo convierte en una muy buena plataforma para poder poner a prueba nuestra herramienta a través de pruenas de usuario para su posterior uso para el gran público. Esa popularidad de Unity da ciertas garantías de que la herramienta será usada y servirá para confeccionar un mínimo de proyectos.
El sistema \textit{drag and drop} facilita mucho el uso de nuestra herramienta y la comprensión de la misma.
Se hará uso de otros elementos de Unity para llevar a cabo esta herramienta como el motor de físicas 2D o las herramientas que tiene el motor para ayudar al usuario a debuggear como puede ser Gizmos.
Unity funciona mediante una arquitectura por componentes, lo que es muy útil para que el programa sea modular, que pueda ser dividido en piezas más pequeñas y que estas piezas sean independientes.\\
\comp{Faltan fotos en este apartado.}

\subsection{Movimiento del jugador}

A la hora de implementar el movimiento del jugador usamos de base la implementación usada por el canal de YouTube \textit{Mix and Jam} en su interpretación del videojuego \textit{Celeste}\footnote{\url{https://www.youtube.com/watch?v=STyY26a_dPY}}.


\subsubsection{PlayerMovement}

La clase \textit{PlayerMovement} actúa como el controlador del jugador. Su función principal es gestionar la entrada del usuario y, en consecuencia, mover al personaje. Además, si el jugador se encuentra en el suelo y se presiona la tecla de salto, la clase se encarga de ejecutar el salto.
Asimismo, maneja una situación particular en la que el jugador queda suspendido en el aire mientras se mueve hacia una pared. Si este caso no se contempla, la fuerza ejercida en el eje X puede anular la del eje Y, haciendo que el personaje quede inmóvil en una posición poco natural. Para evitar este comportamiento, si el jugador está en el aire y colisiona lateralmente con una superficie, se le fuerza a deslizarse a lo largo de esta con una velocidad constante.
Esta clase permite modificar ciertos valores como la velocidad de movimiento, la potencia de salto o la velocidad con la que el jugador se desliza por las superficies anteriormente mencionadas.\\

\textbf{Valores de configuración}
\begin{itemize}
	\item (Float) Speed: Velocidad constante a la que se moverá el jugador.
	\item (Float) Jump Force: Fuerza aplicada al saltar
	\item (Float) Slide Speed: Velocidad aplicada en el eje Y cuando el jugador está en el aire y colisiona lateralmente con una superficie.
\end{itemize}

\subsubsection{PlayerCollisionDetection}

Este script se encarga de detectar las colisiones del jugador. Para ello, se ajustan tres cajas de colisión (\autoref{fig:Player_Coll_Detector}): una en cada lado y otra para detectar el contacto con el suelo. Las cajas no detectan realmente colisiones, si no que comprueban si estas se superponen con alguna entidad de las capas especificadas.
\textit{PlayerCollisionDetection} será usado por \textit{PlayerMovement} para gestionar acciones como determinar cuando el jugador debe deslizarse por una superficie o cuándo puede saltar.\\

\begin{figure}[t]
	\centering
	\includegraphics[width = 0.7\textwidth]{Imagenes/CollDetector.png}
	\caption{Representación de las cajas de detección de colisiones del jugador}
	\label{fig:Player_Coll_Detector}
\end{figure}

\textbf{Valores de configuración}
\begin{itemize}
	\item (Bool) Debug Boxes: En caso de que esta variable sea true, las cajas definidas por los campos que serán presentandos a continuación serán representadas en pantalla con color rojo.
	\item (LayerMask) Detection Layers: Capas que serán tomadas en cuenta para detectar si el jugador está en el suelo o en contacto con una pared cuando está en el aire. En este caso se querrá especificar la capa que albergue a los objetos estáticos que conforman el mundo, por ejemplo \textit{World}.
	\item (Vector2) Bottom/Right/Left Size: Tamaño de las cajas.
	\item (Vector2) Bottom/Right/Left Offsets: Valores usados para reposicionar las cajas para que estén en el lugar considerado por el usuario.
\end{itemize}
\subsubsection{PlayerBetterJumping}

Para que el salto se ajuste más al estándar de los juegos de plataformas 2D, este script mejora la sensación de salto para que el personaje caiga más rápido, evitando una sensación de flotación. Además, permite realizar saltos más pequeños si el jugador suelta el botón antes.\\
Para lograrlo, el script ajusta dos multiplicadores: uno que incrementa la gravedad cuando el jugador está cayendo y otro que reduce la altura del salto cuando este es interrumpido antes de tiempo.\\

\textbf{Valores de configuración}
\begin{itemize}
	\item (Float) Fall Multiplier: Multiplicador que aumenta la gravedad cuando el personaje está cayendo, hace que el personaje caiga más rapido, dándole más peso y realismo al salto.
	\item (Float) Low Jump Multiplier: Multiplicador que aumenta la gravedad cuando el jugador suelta el botón de salto antes de llegar al punto más alto del salto haciendo que se puedan hacer saltos cortos dando más control del movimiento al jugador.
\end{itemize}
\subsection{Life}

Se ha implementado una clase Life que gestiona los puntos de salud del objeto al que está adjunto y que se encarga de eliminar el objeto en el caso que su vida llegue a cero. El componente pedirá al usuario un valor inicial para los puntos de vida del objeto y un valor máximo al que puede llegar la vida, para que esta sea limitada en caso de que se quiera implementar un sistema de recuperación de vida.\\
Este componente está estrechamente ligado al \textit{DamageSensor} el cual será mencionado más adelante y que detecta si ha habido una colisión con un objeto que aplique daño, esta relación es necesaria ya que para que se detecte el daño que decrementa la salud del objeto se necesita este sensor, por lo que al añadir un componente \textit{Life} se añadirá este sensor automáticamente.\\
\textit{Life} diferencia entre enemigos y el jugador, en caso de que el componente esté adjunto al jugador se deberá marcar en la opción \textit{EntityType} y el componente requerirá que se le de la referencia a un texto del \textit{Canvas} donde se escribirá la vida actual del jugador.\\

\textbf{Valores de configuración}
\begin{itemize}
	\item (enum) Entity Type: Enumerado usado para diferenciar entre jugador y enemigos.
	\item (Float) Initial Life: Cantidad de vida con la que inicia la entidad.
	\item (Float) Max Life: Cantidad de vida máxima a la que puede llegar la entidad.
	\item (String) Text Name: En caso de ser el jugador se pedirá un texto que precederá a los puntos de vida del jugador.
	\item (TextMeshProUGUI) Life Text: Objeto del Canvas usado para representar los puntos de vida actuales del jugador.
\end{itemize}

\subsection{PlayerDistanceAttack}

Componente encargado de representar un posible ataque a distancia del jugador. El ataque se activará con el clic izquierdo del ratón, lo que instanciará el prefab \textit{Bullet Prefab} en la posición del jugador (será importante que no el objeto instanciado no pueda colisionar con el jugador), el cual deberá albergar el comportamiento de una bala. La dirección que tomará la bala será aquella en la que se encuentre el cursor del ratón en el momento del clic.

Para evitar que el jugador pueda disparar sin restricción, se ha introducido un tiempo de espera entre disparos.\\

\textbf{Valores de configuración}
\begin{itemize}
	\item (GameObject) Bullet Prefab: Objeto que se instancia en la posición del jugador al hacer clic.
	\item (Float) Shooting Cooldown: Tiempo necesario (en segundos) antes de poder disparar nuevamente.
\end{itemize}

\section {FSM}

El comportamiento de la entidad estará encapsulado en una FSM, cuya única funcionalidad es la de gestionar el estado actual, comprobar que no ha habido ningún cambio de estado y, en caso de haberlo, manejar el cambio de estado.\\
Esta comprobación se hará al finalizar la actualización del estado actual (en el \texttt{LateUpdate}) para así evitar problemas con cambiar de estado en medio de un bucle sin terminar.

\textbf{Valores de configuración}
\begin{itemize}
	\item (State) Initial State: Estado inicial de la FSM.
\end{itemize}

\subsection{Transition}
Esta clase representa una transición de estado. Está compuesta por un sensor y un estado objetivo.\\
Si el sensor se activa, la entidad cambiará automáticamente al estado especificado.\\

\textbf{Valores de configuración}
\begin{itemize}
	\item (Sensors) Sensor: Sensor encargado de detectar el evento que hará que el cambio de estado se dé.
	\item (State) Target State: Estado de destino de la transición.
\end{itemize}

\subsection{State}

La clase \textit{State} representa un estado de comportamiento de un enemigo. Para ello gestiona dos elementos fundamentales: \textit{Actuators} y \textit{Sensores}.\\

\textbf{Valores de configuración}
\begin{itemize}
	\item (List<Actuator>) Actuator List: Lista de Actuator que son actualizados en cada bucle y representan acciones, se abordarán a continuación.
	\item (List<SensorStatePair>) Transition List: Lista de Transition que pueden ser activadas, lo que supone un cambio de estado al estado objetivo.
	\item (List<DamageEmitter>) Damage Emitter in State: Lista de DamageEmitter activos en el estado y que son los encargados de reportar daño.
	\item (Bool) Debug State: Booleano utilizado para indicar si se quiere que los Actuators en \textit{Actuator List} y Sensores en \textit{Transition List} muestren información a través del Gizmos.
\end{itemize}
Cuando se produce un cambio de estado, todos los actuadores y sensores se detienen, y los sensores se desuscriben de todas las transiciones a los que estuvieran vinculados.\\

\section{Actuator}

Como se ha mencionado anteriormente, un actuator es el script encargado de ejecutar una acción, por lo que para cada tipo de acción existirá un actuator que la represente.
La clase \textit{Actuator} representa la clase base de la que heredarán todos los tipos de actuadores.
Esta clase contiene métodos abstractos para iniciar, actualizar y destruir un actuador. Al ser abstractos cada clase que herede de \textit{Actuator} deberá implementar estos métodos.\\

\subsection{MovementActuator}
Movement contenido a ver si sale guay
\subsubsection{HorizontalActuator}
aaaaa
\subsubsection{VerticalActuator}
aaaaa
\subsubsection{DirectionalActuator}
aaaaa
\subsubsection{CircularActuator}
aaaaa
\subsubsection{SplineActuator}
aaaaa
\subsubsection{MoveToAPointActuator}
aaaaa
\subsubsection{MoveToAnObjectActuator}
aaaaa

\subsection{SpawnerActuator}
Spawner

\section{Sensors and Emitters}

Para que exista una comunicación entre la entidad y su entorno, esta necesita poder recibir y enviar información. Con este propósito se diseñan los sensores y los emisores.\\

\subsection{Sensor}

La clase \textit{Sensor} es de la que heredarán los sensores explicados a continuación. Esta clase contiene variables como el evento que almacena las funciones que se deberán de llamar en caso de que el sensor sea activado, como puede ser la función que activará la transición posteriormente.\\

Cualquier clase que herede de \textit{Sensor} deberá implementar los métodos abstractos \texttt{StartSensor()} y \texttt{StopSensor()}, que son utilizados para gestionar variables de control, gestionar errores o crear los \textit{Timers} en caso de que querramos desactivar un sensor por una cantidad de tiempo (segundos) al iniciarse. También se incluye un modo debug opcional, activable mediante el método \texttt{SetDebug(bool)}, método que será llamado desde State y tomará el valor de la variable \textit{Debug State} del estado.\\

La funcionalidad de los sensores se ha implementado de manera que si se quiere suscribir desde un componente a un evento de cualquier sensor se podrá hacer siempre y cuando la función que será llamada en caso de activarse el sensor reciba un objeto de tipo \textit{Sensor}.\\

\comp{Veo la explicación confusa y con una imagen sería más claro, es raro poner una imagen de un trozo de código? Entiendo que sí.}

La implementación del evento incluye un contador de suscriptores que permite llevar un control interno sobre cuántos componentes están actualmente registrados para recibir notificaciones del sensor. Esta es una práctica útil para evitar errores en tiempo de ejecución.\\

Es importante tener en cuenta que toda suscripción a un sensor debe ir acompañada, en algún momento, de su correspondiente desuscripción. Un caso típico es realizar esta desuscripción cuando la entidad es destruida, utilizando el método \texttt{OnDestroy}.\\

A continuación se enumerarán y explicarán los tipos de sensores incluidos en la herramienta.\\
\subsubsection{AreaSensor}

\subsubsection{CollisionSensor}
aaaaa
\subsubsection{DamageSensor}
aaaaa
\subsubsection{DistanceSensor}
aaaaa
\subsubsection{TimerSensor}
aaaaa

\subsection{Emitters}
muchisimo mas
\subsubsection{DamageEmitter}
aaaaa

\section{Animations}
\subsection{AnimatorManager}
aaaaa

\section{¿Editors?}
Yo no lo pondría pero no sé.

