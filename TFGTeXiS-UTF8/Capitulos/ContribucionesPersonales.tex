\chapter{Contribuciones Personales}
\label{cap:contribucionesPersonales}

En esta sección se describen las aportaciones individuales de cada autor al desarrollo de la herramienta y la elaboración de la memoria. Aunque en la mayoría de los casos ambos autores han participado en conjunto, provocando que una misma tarea esté en ambos autores a la misma vez.

\section{Contribuciones de Cristina Mora Velasco}
\subsection{Antecedentes}
En el verano anterior al inicio del proyecto, comencé una investigación exhaustiva enfocada en cómo desarrollar herramientas efectivas, poniendo especial atención en facilitar las tareas de los diseñadores. El objetivo principal era hacer que las funcionalidades fueran lo más intuitivas y visuales posibles, reduciendo al máximo la necesidad de memorizar procedimientos complejos o comandos específicos. Esto es debido a que aunque pueda parecer algo sumamente sencillo, usan muchas herramientas distintas y tienen que tener grandes cantidades de información en la cabeza, haciendo que sea tedioso tener que recordar funcionalidades que pueden ser reconocidas de manera más rápida y sencilla de manera visual. 
Toda la información que recaudé me pareció sumamente relevante ya que hay elementos que pasamos por alto al estar acostumbrados a usarlos diariamente y que para otras personas es algo totalmente nuevo.
Adicionalmente, contaba ya con conocimientos previos sobre el funcionamiento y aplicación de las máquinas de estados. Este tema introducido por primera vez en la asignatura  \textit{Fundamentos de Computadores} y reforzado de forma práctica a lo largo de toda la carrera. Así mismo también había trabajado ya en diferentes proyectos con  \textit{Unity}.
\subsection{Aportaciones}
\subsubsection{Investigación}
Aunque como he dicho antes, inicié una investigación previa en verano sobre las herramientas para diseñadores, en septiembre, empecé a centrarme más específicamente en el tema a tratar, es decir, enemigos en videojuegos 2D. Para eso primero realicé un análisis en profundidad de los distintos tipos de enemigos que existen en el Hollow Knight separando entre enemigos base y jefes finales. Centrándome en los primeros ya que son los que aparecen con más frecuencia. Analice su comportamiento creando descripciones y máquinas de estado sobre su comportamiento lo que me permitió identificar patrones similares entre diferentes enemigos a nivel visual, donde en realidad su funcionamiento es el mismo. Esto se puede ver mucho mejor en el juego Bzzzt que también analicé donde un mismo comportamiento se puede ver hasta en cinco enemigos diferentes. Todo este análisis permitió no solo encontrar elementos comunes como ya he mencionado, sino también encontrar los más repetidos.
Todo esto hizo que tuviera una estructura clara en la cabeza que permitiese ser escalada de forma sencilla y que tuviera todos los comportamientos identificados. \\
Para la realización del análisis de ambos videojuegos observé game plays entorno a las cinco horas para el Hollow Knight y tres horas para el Bzzzt. Mientras tanto apuntaba los comportamientos. Además, también jugué durante otras 3 horas al Hollow Knight, poniendo especial detalle a aquellos enemigos que detectaban la distancia del jugador o volaban ya que su comportamiento era necesario observarlos con más detalle, por ejemplo, para identificar como era el movimiento de vuelo que hacían.\\

En paralelo a este trabajo realicé la lectura de diferentes trabajos realizados como Generador de comportamientos de enemigos para videojuegos 2D de Daniel Quintero o Herramientas De Diseño Basado En Bocetos Del Comportamiento En Videojuegos de Jorge Antonio Magallanes Borbor. Además de los artículos de investigación también use conocimientos de conferencias de la GDC que permitió tener un conocimiento general sobre el  entorno de la herramienta, saber que estaba ya hecho y de qué forma, pudiendo analizarlos encontrando puntos débiles, fortalezas e información relevante para nuestra estructura.

\subsubsection{Confección de la herramienta}
\begin{itemize}
	\item \textbf{Actuator:} Diseño e implementación de clase padre \texttt{Actuator} y relación con sus clases hijas.
\item \textbf{MovementActuator:}  Corrección de errores y mantenimiento de la clase.
  \item \textbf{VerticalActuator:} Implementación del desplazamiento vertical con movimiento constante, resolución de errores en la aceleración. Se incluye el manejo
de colisiones, control de velocidad y comportamiento de lanzamiento.

  \item \textbf{HorizontalActuator:}Implementación del desplazamiento horizontal con movimiento constante, resolución de errores en la aceleración. Se incluye el manejo
de colisiones, control de velocidad y comportamiento de lanzamiento.
  \item \textbf{CcircularActuator:} Implementación del movimiento circular y solución de problemas relacionados con el cálculo de posiciones alrededor de un punto de rotación.
  \item \textbf{SplinesActuator:} Realización de la implementación íntegra del
componente. Desarrollo del movimiento por splines creando una integración del sistema de splines de Unity para permitir enemigos que sigan trayectorias curvas predefinidas.
  \item \textbf{SpawnerActuator:} Realización de la implementación íntegra del
componente. Desarrollo del componente encargado de generar enemigos u objetos, incluyendo control por intervalos, posición, número de repeticiones y listas de objetos y posición.
  \item \textbf{Simplificaciones en Move to a Point:} Revisé el componente de movimiento hacia puntos fijos para mejorar su configuración y permitir comportamientos uniformes o personalizados por waypoint.
  \item \textbf{Collision Sensor:}  Desarrollo del sensor encargado de las colisiones.
  \item \textbf{Sensor:} Implementación de la lógica base del Sensor. 
  \item \textbf{DistanceSensor:}: Implementación del sensor de distancia, incluyendo visualización para depuración y capacidad para identifcar si un objeto se encuentra dentro o fuera del rango especificado.
 \item \textbf{DamageSensor:} Creación de distintos comportamientos que producían daño. Más adelante fueron unificados en uno solo simplificando su uso e integración.
 \item \textbf{ DamageEmitter:} Creación de la lógica encargada de gestionar la emisión de
daño. 
 \item \textbf{TimeSensor:} Implementación del sensor, que envía un mensaje tras un tiempo.
 \item \textbf{Temporizador:} Creación de la clase base Timer que se utiliza para el SpawnerEnemy y para el Sensor de Tiempo.
  \item \textbf{Movimiento inicial del jugador:} Desarrollo de una versión básica del sistema de control del jugador, que más adelante fue mejorado.
  \item \textbf{FSM:}  Creación de la clase que representa la Máquina de Estados y lógica
necesaria.
 \item \textbf{State:}  Creación de la clase que representa el estado y lógica necesaria, incluida transiciones entre estados.
\item \textbf{Gestión de animaciones:} Implementación y diseño íntegro del sistema \texttt{Animator Manager} para conectar los estados de la FSM con las animaciones del enemigo, incluyendo control de dirección (flip) y vinculación con controladores.
\item \textbf{Controladores de animaciones:} Creación de una máquina de estados base con todos los estados más comunes que se dan en los enemigos y que para usarla solo hace falta cambiar los clips de esta.
  \item \textbf{Sistema de vida:} Implementación del componente \texttt{Life}, que gestiona la salud tanto del jugador como de los enemigos, enlazado a sensores de daño.
  \item \textbf{Dibujado de elementos:} Desarrollo de elementos visuales auxiliares dentro de los componentes para facilitar la visualización de trayectorias, áreas de detección y puntos de aparición.
  \item \textbf{Editores personalizados:} Implementación de la lógica necesaria para que la
información requerida en el inspector de Unity fuera acorde a los valores que
se tengan en todo momento.
  \item \textbf{Limitación en la lista de actuadores y creación de transiciones:} Desarrollo de una validación para evitar que un mismo tipo de actuador se añada más de una vez a un mismo estado, evitando errores de ejecución. Además de la implementación de la lista de transiciones.
  \item \textbf{Subscripción a eventos:} Diseño de un sistema de eventos que permite que un sensor mande información.
  \item \textbf{Creación de escenas de enemigos:} Elaboración de escenas de ejemplo que muestran enemigos funcionales usando las distintas combinaciones de sensores, actuadores y estados. Además arreglé errores del nivel de prueba.
  \item \textbf{Documentación:} Documentación del código con comentarios explicativos y en las escenas para facilitar la comprensión del comportamiento de cada enemigo.
  \item \textbf{Tooltips personalizados:} Implementación de descripciones emergentes (tooltips), facilitando el uso de la herramienta sin necesidad de consultar el manual constantemente.
 \item \textbf{Creación del proyecto:} Configuración inicial del proyecto en Unity y sistema de carpetas.
 \item \textbf{Exportación de la herramienta:} Preparación de la herramienta como un paquete Unity exportable, con estructura organizada y funcionalidad probada. 
  \item \textbf{Importación de assets:} Integración de los assets visuales del proyecto y adecuación de sus propiedades para su uso en el framework.
  \item \textbf{Revisión general del código:} Revisión exhaustiva de todo el código fuente para garantizar la limpieza y consistencia.
\end{itemize}

\subsubsection{Parte de la memoria}

organización en orden de aparición en la memoria:
\begin{itemize}
  \item \textbf{Corrección del resumen y de los agradecimientos:} Revisión completa del resumen y agradecimientos.
  \item \textbf{Abstract:} Redacción de el resumen introductorio en inglés y las \textit{keywords}.
  \item \textbf{Introducción:} Redacción completa de los apartados de motivación, objetivos y plan de trabajo, donde se justifica la necesidad de la herramienta y se establece una organización de trabajo.
  \item \textbf{Organización del estado de la cuestión:} Elección de técnicas, herramientas y motores que se iban a explicar, explicadas por mi compañero.
  \item \textbf{Corrección general del estado de la cuestión:} Revisión de los contenidos.
  \item \textbf{Descripción del trabajo:} Explicación detallada de las decisiones de diseño e implementación, reflejando tanto los aspectos técnicos como la justificación de decisiones.
  \item \textbf{Implementación:} Redacción de los Actuators y Animations, es decir el 4.3 y el 4.5
  \item \textbf{Evaluación con usuarios:} Redacción de la sección dedicada a la evaluación, que incluye:
  \begin{itemize}
    \item Introducción.
    \item Objetivos y preguntas de investigación.
    \item Audiencia objetivo.
    \item Duración y Entrono de Realización.
    \item Descripción de Tareas de probador.
    \item Instrucciones iniciales.
    \item Cuestionario SUS.
  \end{itemize}

  \item \textbf{Corrección general de la memoria:} Lectura final completa del documento, detectando errores  y posibles mejoras en redacción.
  \item \textbf{Conclusiones y Trabajo Futuro:} Redacción de la sección dedicada añas conclusiones obtenidas y el trabajo que se realizará en un futuro.
\item \textbf{ Últimas modificaciones:} Revisión final de la memoria y últimas modificaciones propuestas por el tutor.
\end{itemize}

\subsubsection{Manual}
Me encargué íntegramente de la redacción y organización del manual de usuario del framework, tanto en su versión en español como en inglés. Teniendo en mente siempre que tenia que ser accesible para los diseñadores y por tanto no tener ningún tecnicismo en él. El manual pretende ser una parte fundamental de la herramienta que permita comprender a cualquier usuario el funcionamiento de la herramienta y conocer todos sus componentes. \\
La estructura general del manual fue diseñada con el objetivo de guiar al usuario desde la comprensión conceptual de la herramienta hasta su aplicación práctica. Está organizado en los siguientes bloques principales:
 \begin{itemize}
    \item Introducción breve: Contexto de la herramienta, conocimientos que se asumen y estructura del documento.
    \item Funcionalidad de la herramienta y del manual:  Objetivo de la herramienta y del manual.
    \item Publico objetivo: A quién va dirigida la herramienta.
    \item Requisitos e instalación: Descripción por pasos para la instalación. Así como la especificación de recursos necesarios  para esta.
    \item Contenido del paquete: Organización de los archivos que se importan, explicando la utilidad de cada carpeta.
    \item Componentes Detallados: Es el bloque más extenso del manual y el más técnico. Aquí documenté de forma minuciosa todos los elementos del framework. Dividido en secciones: Actuadores, Sensores, Maquinas de estado, animaciones y Vida.
    \item Ejemplos prácticos: Diseñé y documenté cinco ejemplos representativos que abarcan desde enemigos muy simples (como pinchos) hasta comportamientos más complejos.
    \item Preguntas frecuentes y solución a posibles errores: tabla de errores comunes detectados durante el testeo y sus posibles soluciones.
    \item Glosario: Redacté un glosario técnico con definiciones breves y claras de todos los conceptos importantes para facilitar la comprensión a personas no expertas en programación o desarrollo de videojuegos.
    \item Soporte: Incluí la información de contacto para que los usuarios pudieran resolver dudas o proponer mejoras.
  \end{itemize}
También me encargué de la revisión general de los contenidos y de su actualización.

\section{Contribuciones de Francisco Miguel Galván Muñoz}
\subsection{Antecedentes}
Antes de comenzar este proyecto, ya tenía una base sólida sobre Máquinas de Estados gracias a asignaturas como \textit{Fundamentos de Computadores} e \textit{Inteligencia Artificial}, donde implementamos por primera vez una en Unity. En esa práctica, la arquitectura propuesta resultó poco escalable y compleja, especialmente para modelar comportamientos básicos como patrullar, perseguir o atacar, lo que motivó mi interés por buscar soluciones más eficientes.\\

Aunque siempre me había interesado el diseño de enemigos, no lo había explorado teóricamente hasta este proyecto. Durante su desarrollo, investigamos patrones comunes en enemigos de videojuegos 2D, lo que nos permitió identificar comportamientos reutilizables y orientar nuestra herramienta hacia una arquitectura modular y accesible para desarrolladores.\\
 
\subsection{Aportaciones}
\subsubsection{Investigación}
Cuando comenzamos con la etapa de investigación, a mediados de septiembre, tanto Cristina como yo seleccionamos varios videojuegos con el objetivo de analizar el comportamiento de sus enemigos más representativos. En mi caso, elegí \textit{Blasphemous} y adopté una dinámica basada en la observación directa: mientras jugaba, capturaba imágenes cada vez que aparecía un enemigo nuevo y realizaba un análisis detallado de su comportamiento. Esta dinámica la mantuve durante las primeras tres horas de juego, lo cual me permitió identificar paralelismos entre distintos tipos de enemigos, especialmente en lo referente a la forma en que se activaban las transiciones entre estados y cómo variaban sus comportamientos en función del estado en el que se encontraban.\\

Paralelamente a esta labor práctica, llevé a cabo una investigación teórica consultando artículos académicos (\textit{papers}) y conferencias de la GDC (Game Developers Conference), como la de \cite{PlantsVsZombies}, con el fin de comprender cómo se aborda el diseño de enemigos a nivel profesional. Esta información fue de gran utilidad para dar forma a los fundamentos de nuestra herramienta.\\

Una vez finalizada la fase de recopilación de información por ambas partes, celebramos varias reuniones para poner en común los hallazgos, identificar similitudes entre nuestros análisis y definir una base conceptual común. Gracias a este trabajo colaborativo, pudimos orientar adecuadamente la arquitectura de la herramienta, y comenzamos con el diseño e implementación de los primeros sensores y actuadores que formarían parte del sistema.\\

\subsubsection{Confección de la herramienta}
\begin{itemize}
	\item \textbf{Actuator:} Diseño e implementación de clase padre \texttt{Actuator} y relación con sus clases hijas.
	\item \textbf{MovementActuator:} Desarrollo de nuevo nivel de abstracción de \texttt{Actuator} para todas las clases que representen movimientos (se excluye la clase encargada de crear enemigos). Integración de \textit{Easing Functions} en todos los movimientos excepto el movimiento basado en splines.
	\item \textbf{VerticalActuator:} Implementación del desplazamiento vertical con movimiento constante, resolución de errores en la aceleración. Se incluye el manejo de colisiones, control de velocidad y comportamiento de lanzamiento.
	\item \textbf{HorizontalActuator:} Implementación del desplazamiento horizontal con movimiento constante, solución a problemas relacionados con la aceleración. También se contemplan las colisiones, la velocidad y el comportamiento de lanzamiento.
	\item \textbf{CircularActuator:} Implementación del movimiento circular, incluyendo su variante en modo péndulo, con soporte para aceleración mediante \textit{Easing Functions} y visualización de trayectoria para depuración.
  	\item \textbf{SpawnerActuator:} Correción de errores y mantenimiento de la clase.
 	\item \textbf{MoveToAPointActuator:} Realización de la implementación íntegra del componente.
	\item \textbf{MoveToAnObjectActuator:} Realización de la implementación íntegra del componente.
	\item \textbf{DirectionalActuator:} Implementación de la clase surgida de la necesidad de crear proyectiles que fueran hacia el jugador al instanciarse.
	\item \textbf{Sensor:} Implementación de la lógica base de la clase padre \texttt{Sensor}, que sirve como estructura común para los distintos tipos de sensores.
  	\item \textbf{CollisionSensor:} Desarrollo del sensor encargado de detectar colisiones. Se resolvió un bug que impedía detectar colisiones persistentes si el sensor se activaba tras el impacto.
	\item \textbf{DistanceSensor:} Implementación del sensor de distancia, incluyendo visualización para depuración y capacidad para identificar si un objeto se encuentra dentro o fuera del rango especificado.
	\item \textbf{DamageSensor:} Desarrollo inicial y posterior refactorización de toda la lógica del daño, ya que originalmente se utilizaba el sensor tanto para recibir como para emitir daño, lo cual motivó su separación en componentes específicos.
	\item \textbf{DamageEmitter:} Creación de la clase encargada de gestionar la emisión de daño. Esta clase contiene toda la información relevante que se consulta cuando un objeto que inflige daño interactúa con otro que puede recibirlo.
	\item \textbf{Life:} Creación del sistema de vida que gestiona la salud de todas las entidades de la herramienta usando un \texttt{DamageSensor}.
	\item \textbf{TimeSensor:} Solución de error donde se utilizaba una única instancia de \texttt{Timer} para dos tiempos diferentes.
	\item \textbf{PlayerMovement:} Modificación de la clase proporcionada por \textit{Mix And Jam} eliminando lógica que no nos interesaba.
	\item \textbf{PlayerDistanceAttack:} Creación de componente para ataque a distancia del jugador.
	\item \textbf{PlayerCollisionDetection:} Modificación de la clase proporcionada por \textit{Mix And Jam} añadiendo la opción de visualizar las cajas de colisión que detectan los eventos de posibilidad de salto (caja inferior) o de deslizamiento por las paredes (cajas laterales).
	\item \textbf{Solución de errores de animaciones:} Surgió un error donde al eliminar un estado o transición del \texttt{Animator Controller} del que derivan todos los demás, \textit{Unity} no hacía la limpieza de éstos bien dejando basura. Para ello había que borrar manualmente esos bloques de código sobrantes.
	\item \textbf{Editores personalizados:} Implementación de la lógica necesaria para que la información requerida en el inspecto de \textit{Unity} fuera acorde a los valores que se tengan en todo momento.
	\item \textbf{FSM}: Creación de la clase que representa la Máquina de Estados y lógica necesaria.
	\item \textbf{State}: Lógica de la clase excepto transiciones entre estados.
	\item \textbf{Creación de escenas enemigos:} Creación y ajuste de escenas de enemigos de prueba para que fueran lo más cercanos a lo que se ve en un videojuego comercial posible. También realicé un pequeño nivel de prueba donde se combinaban una serie de enemigos.
	\item \textbf{Documentación del código:} Documentación del código para su posible corrección y para que su mantenimiento sea más sencillo.
	\item \textbf{Tooltips personalizados:} Confección de \textit{tooltips} para que el uso de la herramienta fuera más sencillo.
	\item \textbf{Exportación de la herramienta:} Preparación para que la herramienta pueda ser importada desde un repositorio de \textit{GitHub}.
  	\item \textbf{Revisión general del código:} Revisión exhaustiva de todo el código fuente para garantizar la limpieza y consistencia.
\end{itemize}
\subsubsection{Implicación en la memoria}
En cuanto a la redacción de la memoria, estuve involucrado activamente en todo el proceso de elaboración. A continuación, detallo mi participación en cada uno de los capítulos:

\begin{itemize}
 	\item \textbf{Resumen:} Redacción completa del resumen en ambos idiomas, así como de los agradecimientos.
 	\item \textbf{Introducción:} Revisión general de todos los apartados del capítulo.
 	\item \textbf{Estado de la Cuestión:} Redacción completa del capítulo.
 	\item \textbf{Diseño del Framework:} Redacción inicial parcial del capítulo durante la fase de investigación, con posterior revisión de las modificaciones realizadas por mi compañera. Además, a partir de los comentarios del tutor, redacté varios contenidos adicionales, entre ellos, los ejemplos de uso de la herramienta.
 	\item \textbf{Implementación:} Escritura íntegra del capítulo, a excepción de los apartados 4.2 y 4.6, que posteriormente actualicé en base a las observaciones del tutor.
 	\item \textbf{Evaluación con Usuarios:} Revisión completa del capítulo y redacción de los apartados 5.2.5 y 5.2.6, excluyendo la sección dedicada al cuestionario SUS.
 	\item \textbf{Conclusiones y Trabajo Futuro:} Revisión general del capítulo.
 	\item \textbf{Corrección general de la memoria:} Lectura exhaustiva e iterativa del documento para detectar errores y proponer mejoras de redacción.
	\item \textbf{Últimas modificaciones:} Revisión final de la memoria y últimas modificaciones propuestas por el tutor.
\end{itemize}
\subsubsection{Manual}
Mi participación en la elaboración del manual fue de apoyo al principio y con el tiempo acabé encargándome de:
\begin{itemize}
	\item \textbf{Glosario:} Realización del glosario.
	\item \textbf{Actualización de contenidos:} Cada cambio que se hacía en el Framework debía verse reflejado en el manual, por lo que me encargué de ello.
	\item \textbf{Revisión general de contenidos:} Revisión de los contenidos del manual y búsqueda de erratas o contenido que pudiera ser explicado de manera más entendible para un diseñador.
	\item \textbf{Actualización del manual:} Tras las pruebas de usuario, se hicieron una serie de cambios en el manual producto al \textit{feedback} recibido.
\end{itemize}

Todo estas aportaciones se dieron en ambas versiones, español e inglés.